\documentclass[20pt, a1paper, portrait]{tikzposter}
\usepackage[a1paper]{geometry}
\usepackage{mathtools}
\usepackage{amsfonts}
\usepackage{mathrsfs}
\usepackage{decorated}
\usepackage{notation}
\usepackage{theorems}
\usepackage{cmbright}
\usepackage{hyperref}
\usepackage[shortlabels]{enumitem}
\usepackage{bm}

\usetikzlibrary{positioning}

\definecolor{darkblue}{RGB}{0, 76, 153}
\definecolor{lightred}{RGB}{255, 255, 153}
\definecolor{yelloworange}{RGB}{255, 128, 0}
\definecolor{yellowgreen}{RGB}{76, 153, 0}
\definecolor{darkpurple}{RGB}{153, 0, 153}
\definecolor{darkpink}{RGB}{255, 0, 255}
\definecolor{lightred}{RGB}{255, 102, 102}
\definecolor{lightblue}{RGB}{51, 153, 255}
\definecolor{darkerpurple}{RGB}{102, 0, 204}


\colorlet{titlebgcolor}{darkblue}
\colorlet{titlefgcolor}{white}

\colorlet{backgroundcolor}{white}
\colorlet{blocktitlebgcolor}{lightgray}
\colorlet{blocktitlefgcolor}{darkblue}

\colorlet{innerblockbodybgcolor}{white}
\colorlet{innerblocktitlebgcolor}{darkblue}
\colorlet{innerblocktitlefgcolor}{white}

\colorlet{notebgcolor}{lightred}
\colorlet{noteframecolor}{lightred}

\usetitlestyle{Filled}
\usenotestyle{Sticky}

\begin{document}

\title{\textbf{\parbox{\linewidth}{\centering{%
    Algoritmos com predições para caching  }}}}
%
\author{%
  Paulo Henrique dos Anjos\\
  Orientador: Victor Sanches Portella}
%
\maketitle

\node [below right=3cm and 1.5cm] at (bottomleft |- topright) {
    \includegraphics[scale=.08]{images/IME.png}
};


\begin{columns}

\column{0.33}

\block[titleinnersep=.5cm]{Caching tradicional}{

\vspace{.5cm}

\begin{minipage}[c]{0.2\textwidth}

  \vspace*{.5cm}

  Um cache de tamanho \(\mathbf{k}\) processa uma sequência de páginas em ordem. Se uma página não estiver no cache, ocorre uma \textbf{falha de cache} com custo unitário e uma página do cache deve ser descartada e substituída. O objetivo é minimizar o número de falhas.

\end{minipage}
\begin{minipage}[c]{0.22\textwidth}
  \begin{tikzfigure}\label{fig3}
    \centering
    \includegraphics[scale=.1]{images/caching.png}
  \end{tikzfigure}
\end{minipage}%

\vspace*{.5cm}

O custo mínimo \(\opt(\boldz)\) é dada pela estratégia (\textbf{offline}) \textcolor{blue}{\textbf{FIF}} (\emph Furthest-in-the-Future), que descarta a página do cache que permanecerá sem pedidos pelo maior tempo no futuro.


\begin{center}
  \fcolorbox{darkpurple}{white}{
    \begin{minipage}{0.9\linewidth}
      \centering
      \vspace{4pt}
      \textbf{\large Quão perto de \textbf{OPT} um algoritmo online pode chegar?}
      \vspace{4pt}
    \end{minipage}
  }
\end{center}

\innerblock[titleleft]{Análise competitiva}{
  Um algoritmo aleatorizado \(\Acal\) atinge \textcolor{blue}{\textbf{competitivade}} \(\boldalpha\) se para \textbf{toda} sequência de pedidos \(\boldz\) 
  \begin{equation*}
    \frac{\mathbb{E}[\text{\textcolor{red}{Custo}}(\boldz)]}{\opt(\boldz)} \le \boldalpha 
  \end{equation*}
}

\vspace*{.5cm}

Portanto, busca-se algoritmos online com competitivade \(\boldalpha\) o mais próximo possível de \(1\).

\begin{center}
  \fcolorbox{darkpurple}{white}{
    \begin{minipage}{0.9\linewidth}
      \centering
      \vspace{4pt}
      \large \(\boldalpha = \Theta(k)\) para algoritmos \textbf{determinísticos} e
      \(\boldalpha = \Theta(\log k)\) para algoritmos \textbf{aleatorizados}. Na prática, \textcolor{blue}{\textbf{LRU}} é usado, mas pela teoria \(\boldalpha(\text{\textcolor{blue}{\textbf{LRU}}}) = k\)
      \vspace{4pt}
    \end{minipage}
  }
\end{center}

.
\vspace{.5cm}
}

\column{0.33}

\block[titleinnersep=.5cm, roundedcorners=0]{E com predições?}{

  \begin{minipage}[c]{0.2\textwidth}
  \vspace*{.5cm}
  Um algoritmo clássico pode ser aprimorado com um \textbf{oráculo} que prevê entradas futuras. Em \emph{caching}, o oráculo prevê o \textbf{próximo tempo} que uma página será solicitada.
\end{minipage}


\begin{minipage}[c]{0.22\textwidth}
  \begin{tikzfigure}\label{fig3}
    \centering
    \includegraphics[scale=.1]{images/caching-pred.png}
  \end{tikzfigure}
\end{minipage}%

\begin{center}
  \fcolorbox{darkpurple}{white}{
    \begin{minipage}{0.9\linewidth}
      \centering
      \vspace{4pt}
      \textbf{\large Como usar o oráculo para melhorar os algoritmos clássicos?}
      \vspace{4pt}
    \end{minipage}
  }
\end{center}

Buscamos algoritmos:

\begin{itemize}
  \item \textcolor{blue}{\textbf{Consistentes}}: se servido de um oráculo melhor (com erro \(\boldeta\) menor) resulta mais competitivo 
  \item \textcolor{green}{\textbf{Robustos}}: permanece robusto no pior caso, em que o oráculo é arbitrariamente ruim.
\end{itemize}

O algoritmo natural com predições é o \textcolor{blue}{\textbf{OráculoCego}}, que sempre descarta a página prevista a ocorrer mais no futuro ("imitando" a estratégia \textcolor{blue}{\textbf{FIF}}). 

\begin{itemize}
  \item \(\boldalpha(\text{\textcolor{blue}{\textbf{OráculoCego}}}) = \Theta(\frac{\boldeta}{OPT})\)
  \item é, portanto, consistente mas não é robusto.
\end{itemize}

Um algoritmo ótimo que ignora todas as previsões do oráculo é robusto mas não é consistente.

\vspace{.5cm}
}

\column{0.33}

\block[titleinnersep=.65cm]{Algoritmos de marcação}{

  A sequência de pedidos \(\boldz\) é separada em \textbf{fases}. 

  \begin{itemize}
    \item Um acerto de cache \textcolor{blue}{marca} a página correspondente
    \item Após uma falha de cache descarta uma página \textcolor{red}{desmarcada}, traz a página faltante e \textcolor{blue}{marca} ela
    \item Quando todas páginas do cache estão marcadas, inicia-se uma nova fase com todas as páginas desmarcadas. 
  \end{itemize}

  \textbf{Algoritmos de marcação só descartam páginas desmarcadas}: variam apenas na regra de escolha entre as desmarcadas.

\begin{minipage}[c]{0.4\textwidth}
  \begin{tikzfigure}\label{fig3}
    \centering
    \includegraphics[scale=.1]{images/mark.png}
  \end{tikzfigure}
\end{minipage}%

\vspace{.5cm}

  \begin{itemize}
    \item \textcolor{blue}{\textbf{Marker}}: descarta uniformemente uma página desmarcada do cache. 
    \item Sem um oráculo, atinge competitivade \(\alpha(\textcolor{blue}{\textbf{Marker}}) = \Theta(\log k)\).
  \end{itemize}

\begin{center}
  \fcolorbox{darkpurple}{white}{
    \begin{minipage}{0.9\linewidth}
      \centering
      \vspace{4pt}
      \textbf{\large Lykouris (2019) e Rohatgi(2020) mostram como usar um oráculo para melhorar a competitivade do algoritmo \textcolor{blue}{\textbf{Marker}}}
      \vspace{4pt}
    \end{minipage}
  }
\end{center}


\innerblock[titleleft]{Cadeias de descarte}{

  \begin{minipage}[c]{0.2\textwidth}
    \begin{itemize}
      \item Cada página \textcolor{green}{\textbf{nova}}, ou seja, que não esteve presente na fase anterior, inicia uma \textbf{cadeia de descarte}. Essa página não está no cache e resulta no descarte de uma página \textcolor{red}{\textbf{velha}}, cuja próxima ocorrência resulta em outro descarte e assim por diante, até chegar uma página que não aparece de novo na fase. Essas cadeias "explicam" todas as falhas da fase. 
      \item O custo total de falhas é a soma dos comprimentos das cadeias.
    \end{itemize}
  \end{minipage}%
  \hfill
  \begin{minipage}[c]{0.22\textwidth}
    \begin{tikzfigure}\label{fig3}
      \centering
      \includegraphics[scale=.1]{images/cadeia.png}
    \end{tikzfigure}
  \end{minipage}%

}

\vspace{.5cm}

\textcolor{blue}{\textbf{OráculoMarker}} (Lykouris 2019): 
\begin{itemize}
  \item segue o conselho do oráculo no máximo \(\log k\) vezes por cadeia, depois descarta uniformemente até o final da cadeia
  \item \(\boldalpha = 2 + O\left(\min\left(\sqrt{\frac{\boldeta}{\OPT}}, \log k\right)\right)\)
\end{itemize}

\vspace{.5cm}

\textcolor{blue}{\textbf{OráculoMarkerAprimorado}} (Rohatgi 2021): 
  \begin{itemize}
    \item segue o conselho do oráculo apenas uma vez por cadeia, depois descarta uniformemente até o final da cadeia
    \item \(\boldalpha = O\left(1+ \min\left(\log \frac{\boldeta}{\OPT}, \log k\right)\right)\)
  \end{itemize}

A escolha de ignorar o oráculo após um determinado tempo permite robustez, protegendo o algoritmo contra previsões ruins.
}

\block[titleinnersep=.65cm]{Algoritmos simplificados (e melhores...)}{

  \innerblock[titleleft]{Combinando algoritmos em caixa-preta. }{
    \textbf{Teorema (Lykouris 2019)}. Seja \(\Acal\) um algoritmo \(\alpha\)-robusto e \(\Bcal\) um algoritmo \(\gamma\)-competitivo. Existe um algoritmo \(\Ccal\) que é \(9\alpha\)-robusto e \(9\gamma\)-competitivo que combina \(\Acal\) e \(\Bcal\) em "caixa-preta".
  }

\begin{center}
  \fcolorbox{darkpurple}{white}{
    \begin{minipage}{0.9\linewidth}
      \centering
      \vspace{4pt}
      \textbf{\large O \textcolor{blue}{\textbf{OráculoCego}} foi analisado rigorosamente em Wei(2021). Usando o teorema para combinar a consistência do \textcolor{blue}{\textbf{OráculoCego}} com a robustez dos melhores algoritmos disponíveis chega-se em algoritmos melhores e mais simples!}
      \vspace{4pt}
    \end{minipage}
  }
\end{center}

\textcolor{blue}{\textbf{OrácloCego + LRU}}
  \begin{itemize}
    \item \(\alpha = O\left(\min\left(\frac{\eta}{k\OPT}, k\right)\right)\) 
    \item Wei (2021) prova que esse é o "melhor" algoritmo determinístico possível
  \end{itemize}

  \textcolor{blue}{\textbf{OrácloCego + Marker}}
  \begin{itemize}
    \item \(\alpha = O\left(2\min\left(\frac{\eta}{k\OPT}, \log k\right)\right)\)
    \item Rohatgi (2021) mostrou uma cota inferior para algoritmos aleatorizados: \(\alpha \ge \log \min \left(\frac{\eta}{k\log k OPT}\right),k)\)
    \item um pouco longe ainda...
  \end{itemize}
}

\block[titleinnersep=.5cm]{Referências}{
\normalsize

  [1] T. Lykouris e S. Vassilvitskii. Competitive Caching with Machine Learned Advice.

  [2] D. Rohatgi. Near-Optimal Bounds for Online Caching with Machine Learned Advice.

  [3] Alexander Wei. Better and Simpler Learning-Augmented Online Caching.
}

\end{columns}

\end{document}
